<!doctype html><html lang=en-us><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge,chrome=1"><title>09 - Nachbauanleitung: Bird Booth | Anna Marburger</title><meta name=viewport content="width=device-width,minimum-scale=1"><meta name=description content="Einleitung Das Projekt Bird Booth entstand aus der Idee, auch viel beschäftigten Vogelliebhabern die Möglichkeit zu bieten, ihre Besucher zu sehen, und nicht nur das langsam verschwindende Futter über die Zeit zu beobachten. Das smarte Futterhäuschen liefert Bilder und Gewicht von alle Vögeln, die sich an dem Futter bedienen. Das Gewicht liefert einen zusätzlichen Wiedererkennungswert und lässt Beobachter zum Beispiel auch Rückschlüsse auf Gesundheit und Zustand der tierischen Besucher ziehen. Bird Booth soll ein langlebiges und umweltfreundliches Vogelhäuschen sein."><meta name=generator content="Hugo 0.115.4"><meta name=robots content="noindex, nofollow"><link rel=stylesheet href=/swh/ananke/css/main.min.css><link rel="shortcut icon" href=/swh/media/qboyicon.png type=image/x-icon><meta property="og:title" content="09 - Nachbauanleitung: Bird Booth"><meta property="og:description" content="Einleitung Das Projekt Bird Booth entstand aus der Idee, auch viel beschäftigten Vogelliebhabern die Möglichkeit zu bieten, ihre Besucher zu sehen, und nicht nur das langsam verschwindende Futter über die Zeit zu beobachten. Das smarte Futterhäuschen liefert Bilder und Gewicht von alle Vögeln, die sich an dem Futter bedienen. Das Gewicht liefert einen zusätzlichen Wiedererkennungswert und lässt Beobachter zum Beispiel auch Rückschlüsse auf Gesundheit und Zustand der tierischen Besucher ziehen. Bird Booth soll ein langlebiges und umweltfreundliches Vogelhäuschen sein."><meta property="og:type" content="article"><meta property="og:url" content="https://annamarburger.github.io/swh/posts/post9/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-11T12:28:26+02:00"><meta property="article:modified_time" content="2023-07-11T12:28:26+02:00"><meta itemprop=name content="09 - Nachbauanleitung: Bird Booth"><meta itemprop=description content="Einleitung Das Projekt Bird Booth entstand aus der Idee, auch viel beschäftigten Vogelliebhabern die Möglichkeit zu bieten, ihre Besucher zu sehen, und nicht nur das langsam verschwindende Futter über die Zeit zu beobachten. Das smarte Futterhäuschen liefert Bilder und Gewicht von alle Vögeln, die sich an dem Futter bedienen. Das Gewicht liefert einen zusätzlichen Wiedererkennungswert und lässt Beobachter zum Beispiel auch Rückschlüsse auf Gesundheit und Zustand der tierischen Besucher ziehen. Bird Booth soll ein langlebiges und umweltfreundliches Vogelhäuschen sein."><meta itemprop=datePublished content="2023-07-11T12:28:26+02:00"><meta itemprop=dateModified content="2023-07-11T12:28:26+02:00"><meta itemprop=wordCount content="4305"><meta itemprop=keywords content><meta name=twitter:card content="summary"><meta name=twitter:title content="09 - Nachbauanleitung: Bird Booth"><meta name=twitter:description content="Einleitung Das Projekt Bird Booth entstand aus der Idee, auch viel beschäftigten Vogelliebhabern die Möglichkeit zu bieten, ihre Besucher zu sehen, und nicht nur das langsam verschwindende Futter über die Zeit zu beobachten. Das smarte Futterhäuschen liefert Bilder und Gewicht von alle Vögeln, die sich an dem Futter bedienen. Das Gewicht liefert einen zusätzlichen Wiedererkennungswert und lässt Beobachter zum Beispiel auch Rückschlüsse auf Gesundheit und Zustand der tierischen Besucher ziehen. Bird Booth soll ein langlebiges und umweltfreundliches Vogelhäuschen sein."></head><body class="ma0 avenir bg-near-white"><header class="cover bg-top" style=background-image:url(https://annamarburger.github.io/swh/media/haus_drawing.png)><div class=bg-black-60><nav class="pv3 ph3 ph4-ns" role=navigation><div class="flex-l justify-between items-center center"><a href=/swh/ class="f3 fw2 hover-white no-underline white-90 dib"><img src=/swh/media/logo.png class="w100 mw5-ns" alt="Anna Marburger"></a><div class="flex-l items-center"><div class=ananke-socials></div></div></div></nav><div class="tc-l pv6 ph3 ph4-ns"><div class="f2 f1-l fw2 white-90 mb0 lh-title">09 - Nachbauanleitung: Bird Booth</div></div></div></header><main class=pb7 role=main><article class="flex-l flex-wrap justify-between mw8 center ph3"><header class="mt4 w-100"><aside class="instapaper_ignoref b helvetica tracked">POSTS</aside><div id=sharing class="mt3 ananke-socials"></div><h1 class="f1 athelas mt3 mb1">09 - Nachbauanleitung: Bird Booth</h1><p class=tracked>By <strong>Anna Marburger</strong></p><time class="f6 mv4 dib tracked" datetime=2023-07-11T12:28:26+02:00>July 11, 2023</time>
<span class="f6 mv4 dib tracked">- 21 minutes read</span>
<span class="f6 mv4 dib tracked">- 4305 words</span></header><div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><h2 id=einleitung>Einleitung</h2><p>Das Projekt Bird Booth entstand aus der Idee, auch viel beschäftigten Vogelliebhabern die Möglichkeit zu bieten, ihre Besucher zu sehen, und nicht nur das langsam verschwindende Futter über die Zeit zu beobachten. Das smarte Futterhäuschen liefert Bilder und Gewicht von alle Vögeln, die sich an dem Futter bedienen. Das Gewicht liefert einen zusätzlichen Wiedererkennungswert und lässt Beobachter zum Beispiel auch Rückschlüsse auf Gesundheit und Zustand der tierischen Besucher ziehen.
Bird Booth soll ein langlebiges und umweltfreundliches Vogelhäuschen sein.</p><br><h3 id=materialien-und-zubehör>Materialien und Zubehör</h3><h5 id=technik>Technik</h5><ul><li>ESP32 CAM 2,4 GHz WiFi mit OV2640 Kamera Modul</li><li>Elektronischer Gewicht Sensor (3kg)</li><li>HX711 LoadCell Amplifier</li><li>Vibrationssensor SW420</li><li>Batterie-Case mit 3x AAA-Batterien(1,5V)</li></ul><h5 id=zusätzliches-material>Zusätzliches Material</h5><ul><li>2 Lochraster-Platinen</li><li>Kleines Scharnier einschließlich Schrauben</li><li>Holzlasur auf Wasserbasis</li><li>Holz nach Wahl (5 Platten mit 1cm Dicke für Wände und Boden, 4 Platten mit 3mm für das Dach, Zwischenboden und Futterplatte)</li><li>Dachpappe</li><li>2 kleine Plexiglasplatten</li><li>2 kleine Magnete</li><li>2x Schrauben (Maße: Durchmesser 5mm, Kopfdurchmesser max. 9mm, Länge ca 25mm), einschließlich 2 passenden Muttern</li><li>Eine Schraube (Maße: Durchmesser 5mm, Kopfdurchmesser max. 9mm, Länge 15-25mm), einschließlich passender Mutter (Für Sensor-Case unten)</li><li>Eine Schrauben (Maße: Durchmesser 4mm, Kopfhöhe max. 4.5mm, Länge 15-25mm), einschließlich passender Muttern (Für Sensor-Case Innen)</li><li>8 kleine Nägel</li><li>Holzstab Durchmesser 10mm, Länge 105mm</li></ul><h5 id=zubehör>Zubehör</h5><ul><li>FTDI232 Adapter (USB auf Serielles TTL) und USB Kabel</li><li>3D-Drucker mit PLA Filament</li><li>Bandsäge und Stichsäge</li><li>Akku-/Bohrschrauber</li><li>Holzleim, 2-Komponenten-Kleber, Heißkleber</li><li>Kabel, Lötzubehör, Schrumpfschläuche</li></ul><h5 id=zum-testen>Zum Testen</h5><ul><li>Steckplatine</li><li>Jumperkabel</li></ul><h5 id=optional>Optional</h5><ul><li>weiße Acrylfarbe</li><li>kleine, platte Holzstäbchen für die Fensterrahmen</li><li>Makramee-Fäden</li></ul><br><h3 id=dateien-bibliothek>Dateien-Bibliothek</h3><h4 id=code>Code</h4><ul><li><a href=https://github.com/AnnaMarburger/smartesfutterhaus>Server Code</a></li><li><a href=https://github.com/AnnaMarburger/swh/blob/main/birdbooth_files/esp_code.ino>ESP Code</a></li></ul><h4 id=3d-druck-modelle-stl>3D-Druck-Modelle (.stl)</h4><ul><li><a href=https://github.com/AnnaMarburger/swh/blob/main/birdbooth_files/sensorcase_deckel.stl>Sensor-Case Deckel</a></li><li><a href=https://github.com/AnnaMarburger/swh/blob/main/birdbooth_files/sensorcase_zwischenblatt.stl>Sensor-Case Zwischenblatt</a></li><li><a href=https://github.com/AnnaMarburger/swh/blob/main/birdbooth_files/sensorcase_unten.stl>Sensor-Case Unterteil</a></li><li><a href=https://github.com/AnnaMarburger/swh/blob/main/birdbooth_files/futterschale_unten.stl>Futterschale Unterteil</a></li><li><a href=https://github.com/AnnaMarburger/swh/blob/main/birdbooth_files/cam-case.stl>Kamera-Case</a></li></ul><h4 id=lötplan>Lötplan</h4><ul><li><a href=https://github.com/AnnaMarburger/swh/blob/main/birdbooth_files/schaltplan.png>schaltplan.png</a></li></ul><br><h2 id=schritt-für-schritt-anleitung>Schritt-für-Schritt Anleitung</h2><h3 id=1-website-programmieren-server-aufsetzen-und-hosten>1. Website programmieren, Server aufsetzen und hosten</h3><figure><img src=../media/projekt/server_desktop.png></figure><h4 id=11-projekt-aufsetzen-umgebungen-installieren>1.1 Projekt aufsetzen, Umgebungen installieren</h4><p>Um später die Bilder der Futterhaus-Kamera zusammen mit den Gewichtsdaten von überall einsehen zu können, setzen wir einen Server auf. Dieser soll zum einen POST-Requests mit den Daten, die wir später von dem Kamera Modul senden, annehmen und in einer Datenbank speichern können. Zum anderen soll er Webclients, die unsere Website aufrufen, eine HTML mit den aufgearbeiteten Daten (Bildern) zurückgeben.</p><p>Um den Server zu realisieren verwende ich die Laufzeitumgebung <a href=https://nodejs.org/de>Node Js</a>. Ist diese noch nicht installiert, sollte dies zuerst geschehen.</p><p>Nun legen wir ein Verzeichnis an, in welchem wir unsere Anwendung aufbauen. Mit <code>npm init</code> wird eine neue package.json Datei erstellt. In dieser können wir unter anderem den Namen unserer Anwendung festlegen, sowie unter “main” den Namen unsere Hauptdatei, die für das Starten des Servers verantwortlich ist. Bevor wir genau diese Datei anlegen, in meinem Fall “app.js”, fügen wir der package.json Datei ein weiteres Attribut hinzu: <code>“type”:module</code>.</p><p>Um das Coden einfacher zu gestalten, verwende ich das Framework <a href=https://expressjs.com>Express Js</a> . Dieses lässt sich mit dem Package Manager npm durch <code>npm install express</code> installieren. Dabei ist wichtig, dass wir uns im Verzeichnis unserer Anwendung befinden. Mit <code>node app.js</code> kann der Server lokal getestet werden. Hierzu ist zudem das Programm <a href=https://www.postman.com>Postman</a> hilfreich, das über eine einfache Benutzeroberfläche Server Requests verschicken lässt</p><figure><img src=../media/projekt/postman_request.png alt="Screenshot POST-request in Postman"><figcaption><p>Screenshot POST-request in Postman</p></figcaption></figure><p>(Achtung: Für Anfragen an lokale Server wird hierbei die Desktop App benötigt).</p><h4 id=12-datenspeicherung-mit-firebase>1.2 Datenspeicherung mit Firebase</h4><p>Für die Datenspeicherung verwende ich Firebase. Um das Projekt dort anzulegen, wird ein Konto benötigt. Anschließend kann über “Projekt hinzufügen”, ein neues Projekt erstellt werden. Ist dies getan, öffnet sich die Konsole für das Projekt. Dort sollte die App dem Projekt hinzugefügt werden. Da wir eine Webanwendung bauen, wählen wir dort “Web” aus und geben den Namen unseres Servers ein. Über Firebase kann der Server später auch gehostet werden, dann sollte der Haken bei dieser Option gesetzt werden. Ich habe dafür jedoch einen anderen (kostenlosen) Anbieter gewählt: <a href=https://render.com/>Render</a>. Anschließend muss firebase in unserem Projekt installiert werden: <code>npm install firebase</code>. Firebase zeigt nun einen Codeblock an:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-jsx data-lang=jsx><span style=display:flex><span><span style=color:#75715e>// Import the functions you need from the SDKs you need
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>initializeApp</span> } <span style=color:#a6e22e>from</span> <span style=color:#e6db74>&#34;firebase/app&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Your web app&#39;s Firebase configuration
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>firebaseConfig</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>apiKey</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#34;...&#34;</span>,
</span></span><span style=display:flex><span>  ...
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// Initialize Firebase
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>app</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>initializeApp</span>(<span style=color:#a6e22e>firebaseConfig</span>);
</span></span></code></pre></div><p>Wichtig hier ist die Firebase Configuration für unsere Anwendung, da diese für jedes angelegte Firebase Projekt individuell ist. Dieser Teil muss also kopiert und in unserer Hauptdatei <em>app.js</em> entsprechend ersetzt werden. Nun müssen wir in der Firebase Konsole nur noch unseren Speicher einrichten. Unter “Entwickeln” im Seitenmenü wählen wir “Storage” aus und drücken auf der Seite auf “Jetzt Starten”. Die Sicherheitsregeln setzen wir (zum Entwickeln) auf öffentlich. In diesem Speicherbucket können wir nun einen Ordner “images” erstellen. Hier lädt unser Server alle einkommenden Bilder hoch.</p><figure><img src=../media/projekt/screen_firebase.png alt="Screenshot des Firebase-Storage"><figcaption><p>Screenshot des Firebase-Storage</p></figcaption></figure><p>Außerdem muss die Datei <em>data.json</em> in diesem Storage von Hand erstmals hochgeladen werden, da der Server versucht, diese herunterzuladen, sobald er eine “GET” Request von einem Clienten erhält. Beim allerersten Serverstart würde dieser dementsprechend einen Fehler werfen, wenn er dort keine <em>data.json</em> Datei findet.</p><h4 id=13-hosting>1.3 Hosting</h4><p>Für das Hosten des Servers auf Render wird lediglich ein GitHub Repository mit dem Servercode benötigt. Der Anbieter deployed mit jedem Commit den Server erneut. Außerdem gibt es eine Konsole, in der Ausgaben des Servers eingesehen werden können (Hilfreich zum Debuggen). Render selbst führt gut verständlich durch den Hosting Prozess.</p><h4 id=14-aufbau-des-servers>1.4 <strong>Aufbau des Servers:</strong></h4><p>Der gesamte Code für den Server ist auf folgendem Repo zu finden:</p><p><a href=https://github.com/AnnaMarburger/smartesfutterhaus>https://github.com/AnnaMarburger/smartesfutterhaus</a></p><ol><li><p>Die <em>app.js</em> Datei, auch die Hauptdatei, die für das eigentliche Erstellen des Servers verantwortlich ist. In dieser Datei werden “POST”, “GET” und “DELETE” Anfragen gehändelt. Einkommende POST Anfragen werden auf Richtigkeit geprüft und anschließend bearbeitet. Bilder werden direkt mit einem eindeutigen Namen (durch Datum+Uhrzeit) im Firebase Storage gesichert.</p></li><li><p>Die <em>index.html</em> Datei ist die Datei, welche an Clienten bei GET Requests geschickt wird. In ihr werden die Buttons zum Filtern und Sortieren definiert. Außerdem sind in ihr die Dateien <em>gallery.js</em> und <em>style.css</em> verlinkt.</p></li></ol><p>Im <em>Public Ordner</em>, welchen wir als solchen in <em>app.js</em> deklarieren (dies ist wichtig, um Clienten den Zugriff auf benötigte Dateien wie z.B. stylesheets möglich zu machen, die wir nicht per se mitschicken):</p><ol start=3><li><p><em>gallery.js</em> ist die JavaScript Datei, die sich um das dynamische Anzeigen der Daten auf der Website kümmert. Sie liest aus der “data.json” jeweils Bildname, zugehöriges Gewicht und Datum aus und zeigt diese Daten für jeden Eintrag als Galerie-Item auf der Website an. Des Weiteren händelt sie die Filter- und Sortierungs-Optionen, die durch die Buttons auf der Seite getriggert werden.</p></li><li><p>In der Datei <em>style.css</em> wird das Aussehen der Website entsprechend festgelegt.</p></li><li><p>Die bereits erwähnte <em>data.json</em> Datei verwaltet die Metadaten zu jedem Bild, das den Server erreicht. Dazu gehören Name der Bilddatei, sodass sie in den Files gefunden werden kann, das gemessene Gewicht des zugehörigen Vogels sowie einen Datumsstempel, der beim Empfangen des Bildes hinzugefügt wurde.</p></li></ol><p>Der <em>Uploads Ordner</em> enthält die Bilddateien zum Anzeigen nach Herunterladen aus dem Firebase Speicher.</p><br><h3 id=2-kameramodul>2. Kameramodul</h3><h4 id=21-schaltplan>2.1 Schaltplan</h4><p>Unsere Kamera-Komponente besteht aus zwei Teilen: Zum einen die ESP32-Cam, die mit einem ESP32 Microchip arbeitet, zum anderen das OV2640 Kameramodul, sprich die Kamera selbst. Werden beide Teile getrennt geliefert, so muss der längliche Klipser auf der ESP32-Cam vorsichtig aufgemacht und das Kameramodul so reingeschoben werden, dass die Kamera nach vorne zeigt und sicher hält.</p><p>Da die ESP32-Cam keinen USB-Anschluss mitbringt, benötigen wir, um sie zu programmieren, einen USB-to-TTL Adapter, wie zum Beispiel den FTDI. Diesen können wir mithilfe eines Breadbords anschließen:</p><figure><img src=../media/projekt/steckplatine.jpeg alt="ESP+FTDI auf Steckplatine" width=60%><figcaption><p>ESP+FTDI auf Steckplatine</p></figcaption></figure><p>Dabei sollten wir darauf achten, dass auf dem Adapter die Bridge zu 5V gesetzt ist. Zwar läuft der Esp laut Dokumentation auch mit 3.3V, jedoch wurden hierbei zahlreiche Probleme in Online Foren reported. Zusätzlich müssen wir die ESP32-Cam, um Code hochladen zu können, in den “Flashing Mode” setzen. Dies machen wir, indem wir die Pins GPIO0 und GND verbinden. Der Schaltplan sieht demnach folgendermaßen aus:</p><figure><img src=../media/projekt/schaltplan_esp.jpeg alt="Schaltplan ESP+FTDI"><figcaption><p>Schaltplan ESP+FTDI</p></figcaption></figure><h4 id=22-programmieren>2.2 Programmieren</h4><p>Um den ESP-32 Microchip programmieren zu können, müssen wir das Board in der Arduino IDE installieren. Dazu fügen wir in den Einstellungen folgenden Link dem Feld “Additional boards manager URLs” hinzu und speichern:</p><p><a href=https://dl.espressif.com/dl/package_esp32_index.json>https://dl.espressif.com/dl/package_esp32_index.json</a></p><p>Im Boards Manager können wir nun nach “esp32” suchen und installieren. Anschließend sollten wir unter Tools>Board>esp32 die “AI Thinker Esp32 Cam” auswählen können. Unter Port wählen wir den entsprechenden USB Port aus, an welchem wir den Adapter eingesteckt haben.</p><figure><img src=../media/projekt/select_AIThinkerCam.png alt="Screenshot Board-Auswahl"><figcaption><p>Screenshot Board-Auswahl</p></figcaption></figure><p>Unter File > Examples gibt es verschiedene Beispielprogramme, um den ESP zu testen, so auch zum Beispiel auch ein Programm, dass auf einem lokalen Server einen Livestream der Kamera startet und die verschiedensten Einstellungen treffen lässt. Der Code findet sich unter File > Examples > ESP32 > Camera > CameraWebServer.</p><p>Während dem Upload des Codes, wenn auf der Konsole “Connecting…” erscheint, muss das Board einmal resettet werden. Auf der Rückseite gibt es dazu einen kleinen Reset-Knopf. Da man daran aber schlecht herankommt, wenn man ein Breadboard verwendet, kann man alternativ das Kabel zu 5V am Board kurz aus- und wieder einstecken.</p><p>Nun sollten wir dazu bereit sein, unseren eigentlichen Code für die ESP32-Cam zu schreiben. Wir erstellen eine neue Arduino Datei. Zunächst brauchen wir folgende Libraries:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;Arduino.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;WiFi.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;WiFiClientSecure.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;soc/soc.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;soc/rtc_cntl_reg.h&#34;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;esp_camera.h&#34;</span><span style=color:#75715e>
</span></span></span></code></pre></div><p>Anschließend legen wir folgende Variablen für die WiFi Connection fest:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>//WIFI
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> ssid <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;INSERT_YOUR_SSID&#34;</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>char</span><span style=color:#f92672>*</span> password <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;INSERT_PASSWORD_FOR_SSID&#34;</span>;
</span></span><span style=display:flex><span>String serverName <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;INSERT_SERVER_URL&#34;</span>; <span style=color:#75715e>//for me: smartesfutterhaus.onrender.com
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>String serverPath <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;/&#34;</span>; 
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> serverPort <span style=color:#f92672>=</span> <span style=color:#ae81ff>443</span>; <span style=color:#75715e>//server port for HTTPS
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>WiFiClientSecure client;
</span></span></code></pre></div><p>Hierbei müssen SSID und Passwort natürlich mit den eigenen Werten gefüllt werden, sprich mit Name und Passwort der WLAN-Verbindung. Auch die Server-URL muss individuell eingetragen werden.</p><p>Um die AI-Thinker Camera vom ESP32 zu verwenden, müssen wir folgende Pins definieren:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>// CAMERA_MODEL_AI_THINKER
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#75715e>#define PWDN_GPIO_NUM     32
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define RESET_GPIO_NUM    -1
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define XCLK_GPIO_NUM      0
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SIOD_GPIO_NUM     26
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define SIOC_GPIO_NUM     27
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define Y9_GPIO_NUM       35
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define Y8_GPIO_NUM       34
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define Y7_GPIO_NUM       39
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define Y6_GPIO_NUM       36
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define Y5_GPIO_NUM       21
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define Y4_GPIO_NUM       19
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define Y3_GPIO_NUM       18
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define Y2_GPIO_NUM        5
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define VSYNC_GPIO_NUM    25
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define HREF_GPIO_NUM     23
</span></span></span><span style=display:flex><span><span style=color:#75715e>#define PCLK_GPIO_NUM     22
</span></span></span></code></pre></div><p>Nun konfigurieren wir in der setup Methode zum einen die WiFi-Verbindung (wir verwenden den STA Modus), zum anderen die Kamera (diese ist durch das Modell erneut vorgegeben).
Zuletzt versuchen wir, die Cam zu initialisieren. Tritt hierbei ein Fehler auf, soll eine Fehlermeldung ausgegeben werden und nach einem kurzen Delay ein Neustart des ESP hervorgerufen werden.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>//SETUP
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>setup</span>() {
</span></span><span style=display:flex><span>  WRITE_PERI_REG(RTC_CNTL_BROWN_OUT_REG, <span style=color:#ae81ff>0</span>); <span style=color:#75715e>//BROWN OUT DETECTOR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  Serial.begin(<span style=color:#ae81ff>115200</span>); <span style=color:#75715e>//BAUD RATE
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//WIFI setup
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  WiFi.enableSTA(true);
</span></span><span style=display:flex><span>  WiFi.mode(WIFI_STA);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>//CAM config
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  camera_config_t config;
</span></span><span style=display:flex><span>  config.ledc_channel <span style=color:#f92672>=</span> LEDC_CHANNEL_0;
</span></span><span style=display:flex><span>  config.ledc_timer <span style=color:#f92672>=</span> LEDC_TIMER_0;
</span></span><span style=display:flex><span>  config.pin_d0 <span style=color:#f92672>=</span> Y2_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_d1 <span style=color:#f92672>=</span> Y3_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_d2 <span style=color:#f92672>=</span> Y4_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_d3 <span style=color:#f92672>=</span> Y5_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_d4 <span style=color:#f92672>=</span> Y6_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_d5 <span style=color:#f92672>=</span> Y7_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_d6 <span style=color:#f92672>=</span> Y8_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_d7 <span style=color:#f92672>=</span> Y9_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_xclk <span style=color:#f92672>=</span> XCLK_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_pclk <span style=color:#f92672>=</span> PCLK_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_vsync <span style=color:#f92672>=</span> VSYNC_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_href <span style=color:#f92672>=</span> HREF_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_sscb_sda <span style=color:#f92672>=</span> SIOD_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_sscb_scl <span style=color:#f92672>=</span> SIOC_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_pwdn <span style=color:#f92672>=</span> PWDN_GPIO_NUM;
</span></span><span style=display:flex><span>  config.pin_reset <span style=color:#f92672>=</span> RESET_GPIO_NUM;
</span></span><span style=display:flex><span>  config.xclk_freq_hz <span style=color:#f92672>=</span> <span style=color:#ae81ff>20000000</span>;
</span></span><span style=display:flex><span>  config.pixel_format <span style=color:#f92672>=</span> PIXFORMAT_JPEG;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// init with high specs to pre-allocate larger buffers
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span>(psramFound()){
</span></span><span style=display:flex><span>    config.frame_size <span style=color:#f92672>=</span> FRAMESIZE_SVGA;
</span></span><span style=display:flex><span>    config.jpeg_quality <span style=color:#f92672>=</span> <span style=color:#ae81ff>10</span>;  <span style=color:#75715e>//0-63 lower number means higher quality
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    config.fb_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    config.frame_size <span style=color:#f92672>=</span> FRAMESIZE_CIF;
</span></span><span style=display:flex><span>    config.jpeg_quality <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>;  <span style=color:#75715e>//0-63 lower number means higher quality
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    config.fb_count <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  <span style=color:#75715e>// CAM init
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  esp_err_t err <span style=color:#f92672>=</span> esp_camera_init(<span style=color:#f92672>&amp;</span>config);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span> (err <span style=color:#f92672>!=</span> ESP_OK) {
</span></span><span style=display:flex><span>    Serial.printf(<span style=color:#e6db74>&#34;Camera init failed with error 0x%x&#34;</span>, err);
</span></span><span style=display:flex><span>    delay(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>    ESP.restart();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In einer zusätzlichen Methode schreiben wir folgenden Code, um uns mit dem WiFi zu verbinden:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>connectWiFi</span>(){
</span></span><span style=display:flex><span>  WiFi.enableSTA(true);
</span></span><span style=display:flex><span>  WiFi.mode(WIFI_STA);
</span></span><span style=display:flex><span>  delay(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>  WiFi.begin(ssid, password);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>int</span> counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span>( WiFi.status() <span style=color:#f92672>!=</span> WL_CONNECTED) {
</span></span><span style=display:flex><span>    delay(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>    Serial.println(<span style=color:#e6db74>&#34;Connecting to WiFi.. &gt; status : &#34;</span> <span style=color:#f92672>+</span> String(WiFi.status()));
</span></span><span style=display:flex><span>    counter<span style=color:#f92672>++</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span>(counter <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>25</span>){
</span></span><span style=display:flex><span>      WiFi.begin(ssid, password);
</span></span><span style=display:flex><span>      counter <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Diesen werden wir später jedes Mal aufrufen, wenn wir den ESP aus seinem sleep modus aufwecken.</p><p>Außerdem schreiben wir eine Methode, die für das tatsächliche Versenden des Fotos verantwortlich ist. Dabei holen wir uns zuerst einen Pointer zum Kamera Frame-Buffer (und starten den ESP neu, falls dies fehlschlagen sollte). Anschließend bauen wir eine Verbindung zu unserem Server auf. Schließlich schreiben wir die Request, senden sie ab und warten auf die Antwort des Servers (dies ist hauptsächlich für Debugging-Zwecke nötig und kann letztendlich weggelassen werden, da wir die Antwort nicht weiter verarbeiten. Alternativ kann bei einer Fehlerausgabe ein erneutes Versenden ausgelöst werden; Darauf habe ich, um die Code Komplexität zu verringern, verzichtet).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>sendPhoto</span>() {
</span></span><span style=display:flex><span>  String getAll;
</span></span><span style=display:flex><span>  String getBody;
</span></span><span style=display:flex><span>	
</span></span><span style=display:flex><span>  <span style=color:#75715e>//get Camera Capture
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  camera_fb_t <span style=color:#f92672>*</span> fb <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>  fb <span style=color:#f92672>=</span> esp_camera_fb_get();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>if</span>(<span style=color:#f92672>!</span>fb) {
</span></span><span style=display:flex><span>    Serial.println(<span style=color:#e6db74>&#34;Camera capture failed&#34;</span>);
</span></span><span style=display:flex><span>    delay(<span style=color:#ae81ff>1000</span>);
</span></span><span style=display:flex><span>    ESP.restart();
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  Serial.println(<span style=color:#e6db74>&#34;Connecting to server: &#34;</span> <span style=color:#f92672>+</span> serverName);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>  client.setInsecure(); <span style=color:#75715e>//skip certificate validation
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  <span style=color:#66d9ef>if</span> (client.connect(serverName.c_str(), serverPort)) {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Serial.println(<span style=color:#e6db74>&#34;Connection successful!&#34;</span>);  
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//send request           
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    String head1 <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;--XXX</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>Content-Disposition: form-data; name=</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>password</span><span style=color:#ae81ff>\&#34;\r\n\r\n</span><span style=color:#e6db74>SWH2023</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>--XXX</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>Content-Disposition: form-data; name=</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>weight</span><span style=color:#ae81ff>\&#34;\r\n\r\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>    String head2 <span style=color:#f92672>=</span> head1 <span style=color:#f92672>+</span> weight;
</span></span><span style=display:flex><span>    String head <span style=color:#f92672>=</span> head2 <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>--XXX</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>Content-Disposition: form-data; name=</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>img</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>; filename=</span><span style=color:#ae81ff>\&#34;</span><span style=color:#e6db74>esp32-cam.jpg</span><span style=color:#ae81ff>\&#34;\r\n</span><span style=color:#e6db74>Content-Type: image/jpeg</span><span style=color:#ae81ff>\r\n\r\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>    String tail <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>--XXX--</span><span style=color:#ae81ff>\r\n</span><span style=color:#e6db74>&#34;</span>;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> imageLen <span style=color:#f92672>=</span> fb<span style=color:#f92672>-&gt;</span>len;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> extraLen <span style=color:#f92672>=</span> head.length() <span style=color:#f92672>+</span> tail.length();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>uint32_t</span> totalLen <span style=color:#f92672>=</span> imageLen <span style=color:#f92672>+</span> extraLen;
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    client.println(<span style=color:#e6db74>&#34;POST &#34;</span> <span style=color:#f92672>+</span> serverPath <span style=color:#f92672>+</span> <span style=color:#e6db74>&#34; HTTP/1.1&#34;</span>);
</span></span><span style=display:flex><span>    client.println(<span style=color:#e6db74>&#34;Host: &#34;</span> <span style=color:#f92672>+</span> serverName);
</span></span><span style=display:flex><span>    client.println(<span style=color:#e6db74>&#34;Content-Length: &#34;</span> <span style=color:#f92672>+</span> String(totalLen));
</span></span><span style=display:flex><span>    client.println(<span style=color:#e6db74>&#34;Content-Type: multipart/form-data; boundary=XXX</span><span style=color:#ae81ff>\r\n\r\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>    client.print(head);
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>    <span style=color:#75715e>//send img
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>uint8_t</span> <span style=color:#f92672>*</span>fbBuf <span style=color:#f92672>=</span> fb<span style=color:#f92672>-&gt;</span>buf;
</span></span><span style=display:flex><span>    size_t fbLen <span style=color:#f92672>=</span> fb<span style=color:#f92672>-&gt;</span>len;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (size_t n<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>; n<span style=color:#f92672>&lt;</span>fbLen; n<span style=color:#f92672>=</span>n<span style=color:#f92672>+</span><span style=color:#ae81ff>1024</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (n<span style=color:#f92672>+</span><span style=color:#ae81ff>1024</span> <span style=color:#f92672>&lt;</span> fbLen) {
</span></span><span style=display:flex><span>        client.write(fbBuf, <span style=color:#ae81ff>1024</span>);
</span></span><span style=display:flex><span>        fbBuf <span style=color:#f92672>+=</span> <span style=color:#ae81ff>1024</span>;
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (fbLen<span style=color:#f92672>%</span><span style=color:#ae81ff>1024</span><span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>        size_t remainder <span style=color:#f92672>=</span> fbLen<span style=color:#f92672>%</span><span style=color:#ae81ff>1024</span>;
</span></span><span style=display:flex><span>        client.write(fbBuf, remainder);
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>    }   
</span></span><span style=display:flex><span>    client.print(tail);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    esp_camera_fb_return(fb);
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> timoutTimer <span style=color:#f92672>=</span> <span style=color:#ae81ff>180000</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> startTimer <span style=color:#f92672>=</span> millis();
</span></span><span style=display:flex><span>    boolean state <span style=color:#f92672>=</span> false;
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>    <span style=color:#75715e>//read answer
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>while</span> ((startTimer <span style=color:#f92672>+</span> timoutTimer) <span style=color:#f92672>&gt;</span> millis()) {
</span></span><span style=display:flex><span>      Serial.print(<span style=color:#e6db74>&#34;.&#34;</span>);
</span></span><span style=display:flex><span>      delay(<span style=color:#ae81ff>500</span>);      
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>while</span> (client.available()) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>char</span> c <span style=color:#f92672>=</span> client.read();
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (c <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;\n&#39;</span>) {
</span></span><span style=display:flex><span>          <span style=color:#66d9ef>if</span> (getAll.length()<span style=color:#f92672>==</span><span style=color:#ae81ff>0</span>) { state<span style=color:#f92672>=</span>true; }
</span></span><span style=display:flex><span>          getAll <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (c <span style=color:#f92672>!=</span> <span style=color:#e6db74>&#39;\r&#39;</span>) { getAll <span style=color:#f92672>+=</span> String(c); }
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (state<span style=color:#f92672>==</span>true) { getBody <span style=color:#f92672>+=</span> String(c); }
</span></span><span style=display:flex><span>        startTimer <span style=color:#f92672>=</span> millis();
</span></span><span style=display:flex><span>      }
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>if</span> (getBody.length()<span style=color:#f92672>&gt;</span><span style=color:#ae81ff>0</span>) { <span style=color:#66d9ef>break</span>; }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    Serial.println();
</span></span><span style=display:flex><span>    client.stop();
</span></span><span style=display:flex><span>    Serial.println(getBody);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>    Serial.println(<span style=color:#e6db74>&#34;Connection to &#34;</span> <span style=color:#f92672>+</span> serverName <span style=color:#f92672>+</span>  <span style=color:#e6db74>&#34; failed.&#34;</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Achtung: Um den Code zu testen, muss &ldquo;weight&rdquo; durch eine beliebige Zahl ersetzt werden. Diese Variable haben wir bisher noch nicht definiert. Dies werden wir in Abschnitt 4 tun, wenn es um den Gewichtssensor geht.
Um beim Testen das Output des Programms sehen zu können, öffnen wir unter Tools > Serial Monitor den Serial Monitor und beachten dabei, dass er auf die richtige BAUD Rate (hier 115200) eingestellt ist.</p><p><strong>Troubleshooting</strong>: Beim Hochladen von Code auf den ESP kommt es gerne mal zu Problemen, oftmals liegt es an manelhafter Stromversorgung. Hier hilft Google weiter. Eine für mich hilfreiche Seite war: <a href=https://docs.espressif.com/projects/arduino-esp32/en/latest/troubleshooting.html>espressif docs</a>.</p><br><h3 id=3-weckfunktion-mit-vibrationssensor>3. Weckfunktion mit Vibrationssensor</h3><p>Damit der ESP in den light sleep geschickt werden kann, während keine Vögel zu Besuch sind, wird ein Vibrationssensor benötigt, um den ESP auch wieder aufwecken zu können. Dazu ergänzen wir unseren Code folgendermaßen:</p><ul><li><p>Wir ergänzen in der setup Methode am Ende:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>//lightsleep init
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>pinMode(<span style=color:#ae81ff>15</span>, INPUT);
</span></span><span style=display:flex><span>gpio_wakeup_enable(GPIO_NUM_15, GPIO_INTR_HIGH_LEVEL);
</span></span><span style=display:flex><span>esp_sleep_enable_gpio_wakeup();
</span></span><span style=display:flex><span>WiFi.disconnect(true);
</span></span><span style=display:flex><span>Serial.println(<span style=color:#e6db74>&#34;Gleich schlafen&#34;</span>); <span style=color:#75715e>//debug output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>Serial.flush(); 
</span></span><span style=display:flex><span>delay(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>esp_light_sleep_start();
</span></span><span style=display:flex><span>delay(<span style=color:#ae81ff>10</span>);
</span></span></code></pre></div><p>Hierbei ist Pin 15 der Pin, an den wir den Vibrationssensor anschließen. Wir legen diesen als WakeUp-Pin fest und trennen anschließend die WiFi-Verbindung. Dies ist nötig, um sie nach Erwachen aus dem sleep modus fehlerfrei wiederherstellen zu können. Anschließend starten wir direkt in den light sleep. Wenn der ESP durch ein Signal des Vibrationssensor geweckt wird, läuft der Code einfach weiter.</p></li><li><p>Wir schreiben eine Methode, die mit jedem Erwachen aus dem sleep modus ausgeführt wird, unsere sogenannte WakeUp-Routine:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>wakeUpRoutine</span>(){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//reconnect to wifi and send image to server
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    connectWiFi();
</span></span><span style=display:flex><span>    sendPhoto();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//back to sleep
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WiFi.disconnect(true);
</span></span><span style=display:flex><span>    Serial.flush();
</span></span><span style=display:flex><span>    delay(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>    esp_light_sleep_start();
</span></span><span style=display:flex><span>    delay(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>    }
</span></span></code></pre></div><p>Nach Senden des Fotos müssen wir, wie oben bereits erklärt, die WiFi Verbindung wieder trennen, bevor wir den ESP wieder in den sleep modus schicken.</p></li><li><p>Nun können wir die loop-Methode schreiben, die sich so lange wiederholt, wie der ESP mit Strom versorgt wird:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>loop</span>() {
</span></span><span style=display:flex><span>    Serial.println(<span style=color:#e6db74>&#34;......... Woke Up ...................&#34;</span>); <span style=color:#75715e>//debugging print
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    wakeUpRoutine();
</span></span><span style=display:flex><span>    delay(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>In dieser brauchen wir nun lediglich unsere WakeUp-Routine aufzurufen. Ein loop-Durchgang entspricht also einem “Aufwachen”, da der ESP am Ende der WakeUp-Routine in den sleep modus versetzt wird.</p></li></ul><br><h3 id=4-all-about-gewichtssensor>4. All about “Gewichtssensor”</h3><p>Um mit den Daten des Gewichtssensors etwas anfangen zu können, brauchen wir ein Amplifier Modul (HX711). Der Schaltplan für diese beiden Komponenten sieht folgendermaßen aus:</p><figure><img src=../media/projekt/schaltplan_loadcell.png alt="Schaltplan Gewichtssensor"><figcaption><p>Schaltplan Gewichtssensor</p></figcaption></figure><p>Hierbei entsprechen die Farben der Kabel des Sensors auf dem Bild den Farben in echt und sollten dementsprechend verlötet werden. Um sicherzugehen ist es aber ratsam, in die Dokumentation der eigenen Teile zu schauen, falls Abweichungen auftreten.</p><p>Das Schaubild zeigt außerdem, wie wir den Gewichtssensor montieren. Dazu brauchen wir folgende Bauteile:</p><figure><img src=../media/projekt/bauteile_gewichtssensor.jpeg alt="Gewichtssensor Bauteile" width=60%><figcaption><p>Gewichtssensor Bauteile</p></figcaption></figure><ul><li>3D-Modelle: Sensor-Case Deckel, Unterteil und Zwischenblatt</li><li>Gewichtssensor mit Amplifier Modul</li><li>2 Schrauben einschließlich passender Muttern</li><li>Holzstange</li></ul><p>Die beiden Muttern dienen dabei als Spacer zwischen dem Gewichtssensor und dem unteren Teil des Cases, bzw. dem Waagblatt, das die Sitzstange hält und zwischen oberen Teil des Cases und Gewichtssensor liegt. Dies ist wichtig, damit der Sensor genug Platz hat, um bei Belastung nach unten gebeugt zu werden.</p><figure><img src=../media/projekt/assemble_gewichtssensor.jpeg alt="Gewichtssensor zusammenbauen" width=60%><figcaption><p>Gewichtssensor zusammenbauen</p></figcaption></figure><p>Ist das Gehäuse zusammengesetzt, werden in die Holzstange (nachdem sie ebenfalls lasiert wurde) zwei Löcher mit 3mm Durchmesser gebort, so dass sie auf die beiden herausschauenden Stäbe gesteckt werden kann. Damit sie sicher hebt, habe ich sie mit 2-Komponenten-Kleber festgeklebt, dies sollte jedoch erst geschehen, wenn der Gewichtssensor zuverlässig funktioniert und das Case nicht mehr geöffnet werden muss. Das Case an sich habe ich nicht verklebt, da es durch den Steck-Mechanismus bereits ausreichend stabile Haftung vorwies.</p><figure><img src=../media/projekt/gewichtssensor.jpeg alt="Gewichtssensor fertig" width=60%><figcaption><p>Gewichtssensor fertig</p></figcaption></figure><p>Um mit jedem Bild auch das aktuell gemessene Gewicht an den Server zu übermitteln, ergänzen wir den bisherigen Code für unseren ESP folgendermaßen:</p><ul><li><p>Das HX711 Modul benötigt eine Library, die wir inkludieren müssen:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&#34;HX711.h&#34;</span><span style=color:#75715e>
</span></span></span></code></pre></div></li><li><p>Des Weiteren definieren wir folgende Variablen, noch vor der setup-Methode:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>//LOADCELL
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> LOADCELL_DOUT_PIN <span style=color:#f92672>=</span> <span style=color:#ae81ff>13</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> LOADCELL_SCK_PIN <span style=color:#f92672>=</span> <span style=color:#ae81ff>12</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#66d9ef>int</span> calibrationfaktor <span style=color:#f92672>=</span> <span style=color:#ae81ff>380</span>; <span style=color:#75715e>//insert your own!
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#66d9ef>long</span> weight;
</span></span><span style=display:flex><span>HX711 scale;
</span></span></code></pre></div><p>Die zwei Pins für DOUT und SCK entsprechen den Pins, die wir am ESP für den Sensor auswählen, ich habe hier Pin 12 und 13 gewählt.
WICHTIG: Der Calibration-Factor ist für jeden Sensor ein anderer. Um diesen herauszufinden, müssen einige Objekte mit bekanntem Gewicht mit dem Sensor gewogen werden. Der Faktor berechnet sich dann folgendermaßen:</p><p>Calibration-Factor = Gemessenes Gewicht / Bekanntes Gewicht.</p><p>Es empfiehlt sich, dies mit einer gewissen Anzahl an Objekten zu machen und anschließen den Mittelwert der erhaltenen Faktoren zu nehmen, um am Ende möglichst genaue Daten zu erhalten.</p></li><li><p>In der setup-Methode müssen wir nun unsere Waage initialisieren</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#75715e>//LOADCELL init
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>scale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);
</span></span><span style=display:flex><span>scale.set_scale(calibrationfaktor);
</span></span><span style=display:flex><span>scale.tare(<span style=color:#ae81ff>5</span>);
</span></span></code></pre></div><p>Mit <code>scale.tare()</code> setzen wir die Waage auf Null. Wenn diese Methode aufgerufen wird, sollte sich also kein Gewicht auf dem Sensor befinden.</p></li><li><p>Nun passen wir noch die WakeUp-Routine des ESP’s an, indem wir vor dem Senden des Fotos zunächst das Gewicht messen, und anschließend das Senden an den Server nur durchführen, wenn das Gewicht einen bestimmten Schwelle überschreitet. Dies verhindert, dass Fotos gesendet werden, wenn der Vibrationssensor fehlerhaft ausgelöst wurde (zum Beispiel durch ein fallendes Blatt oÄ.). Ich habe als Schwellwert 3 Gramm gewählt.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-cpp data-lang=cpp><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>wakeUpRoutine</span>(){
</span></span><span style=display:flex><span>    <span style=color:#75715e>//get weight
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (scale.is_ready()) { 
</span></span><span style=display:flex><span>        weight <span style=color:#f92672>=</span> scale.get_units(<span style=color:#ae81ff>20</span>); <span style=color:#75715e>//get the average of 20 readings
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Serial.print(<span style=color:#e6db74>&#34;Gewicht: &#34;</span>); <span style=color:#75715e>//debug output
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        Serial.println(weight);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        Serial.println(<span style=color:#e6db74>&#34;HX711 not found.&#34;</span>);
</span></span><span style=display:flex><span>        weight <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//check if an object is actually there or if scale empty
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(weight <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>3</span>){
</span></span><span style=display:flex><span>        <span style=color:#75715e>//reconnect to wifi and send image to server
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        connectWiFi();
</span></span><span style=display:flex><span>        sendPhoto();
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//back to sleep
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    WiFi.disconnect(true);
</span></span><span style=display:flex><span>    Serial.flush();
</span></span><span style=display:flex><span>    delay(<span style=color:#ae81ff>100</span>);
</span></span><span style=display:flex><span>    esp_light_sleep_start();
</span></span><span style=display:flex><span>    delay(<span style=color:#ae81ff>10</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></li></ul><br><h3 id=5-finaler-schaltplan-stromversorgung>5. Finaler Schaltplan, Stromversorgung</h3><p>Um die bisher einzelnen Komponenten zusammenzuführen, soll folgender Schaltplan verwendet werden.</p><figure><img src=../media/projekt/schaltplan.png alt="Vollständiger Schaltplan aller Komponenten"><figcaption><p>Vollständiger Schaltplan aller Komponenten</p></figcaption></figure><p>Als Stromversorgung verwenden wir ein Batterie-Case, dass Platz für 3 AAA Batterien beinhaltet. Da die AAA Batterien jeweils 1.5V liefern, erhalten wir so insgesamt 4.5V. Da alle Komponenten mit 3.3-5V arbeiten, brauchen wir so keine zusätzlichen Widerstände und versorgen gleichzeitig alle Komponenten mit genügend Strom.</p><p>Tabelle der Verknüpfungen:</p><table><thead><tr><th>HX711 |</th><th>ESP32-Cam |</th><th>SW420</th></tr></thead><tbody><tr><td>DT</td><td>GPIO13</td><td>-</td></tr><tr><td>SCK</td><td>GPIO12</td><td>-</td></tr><tr><td>-</td><td>GPIO15</td><td>DO</td></tr></tbody></table><p>Ich habe jeweils Vibrationssensor und Amplifier Modul auf eine Platine sowie den ESP auf eine eigene Platine verlötet. Dies ist der Verteilung der Komponenten im Häuschen verschuldet. Während Vibrationssensor und Amplifier unter die Futterschale gehören, muss die ESP-Cam gegenüber der Sitzstange im Häuschen-Inneren angebracht werden. Es empfiehlt sich, die Cam erst später während dem Häuschenfertigungsprozess final zu verlöten, da erst dann abgeschätzt werden kann, wie lang die Drähte ins Häuschen-Innere sein müssen.</p><br><h3 id=6-häuschenfertigung>6. Häuschenfertigung</h3><p>Das Gehäuse für den Gewichtssensor wurde bereits angesprochen. So bleibt noch die Futterschale und das Häuschen selber.</p><p>Für die Futterschale habe ich den unteren Teil, in den dann Vibrationssensor und Amplifier Modul gelegt werden, 3D gedruckt. Da das Gehäuse des Gewichtssensors keinen Platz für Schrauben bietet und es nicht nötig ist, dass der untere Teil der Futterschale abnehmbar ist, wird er mit 2-Komponenten-Kleber an den unteren Teil des Gewichtssensor-Gehäuses geklebt, so dass beide Teile nach unten bündig abschließen.</p><figure><img src=../media/projekt/futterschale_untererTeil.jpeg alt="Futterschale und Sensor-Case" width=60%><figcaption><p>Futterschale und Sensor-Case</p></figcaption></figure><p>Die beiden kleinen Schraubenlöcher auf der Oberseite waren ursprünglich dazu da, um eine Platte von oben drauf zu schrauben, um so die Technik zu schützen. Wird diese Variante präferiert, können diese beibehalten werden, ansonsten sind sie überflüssig und können auch aus dem 3D Modell entfernt werden.</p><p>Um das Häuschen selbst zu bauen, sollen aus beliebigen Holz je nach gewünschter Größe des Hauses passende Wände sowie ein Boden ausgesägt werden. Zwei Wände müssen hierbei mit spitzer Oberseite zugesägt werden. Eine von diesen soll die Vorderseite werden, die andere die Rückseite. In die Vorderseite müssen folgende Ausschnitte:</p><ul><li>Zwei Löcher auf Höhe der Schrauben der Futterschale (siehe oben), Durchmesser 5mm</li><li>Ein rechteckiges Fenster auf Höhe der oberen Seite der Futterschale (Dabei muss bedacht werden, dass ein Deckel später dazugehört, die Schale wird nicht offen bleiben). Durch dieses soll später das Futter in die Futterschale gelangen.</li><li>Ein weiteres Loch, etwas unterhalb der Futteröffnung, um die Kabel ins Häuschen-Innere zu führen.</li><li>Ein weiteres Fenster oberhalb des vorherigen, durch welches später die ESP-Cam fotografiert.</li></ul><p>Dazu habe ich eine Stichsäge verwendet, während ich zum Aussägen der Platten selber eine Bandsäge benutzt habe.</p><figure><img src=../media/projekt/haus_vorne.jpeg alt="Vorderseite des Häuschens" width=60%><figcaption><p>Vorderseite des Häuschens</p></figcaption></figure><p>Vor dem Verkleben sollte das Holz wetterfest gemacht werden. Hierbei habe ich einen wasserbasierte Acryllasur (in der Farbe Nussbaum) verwendet. Die Lasur sollte für die Sicherheit der Vögel eine giftigen Inhaltsstoffe enthalten. Die Ränder der Fenster können optional mit mit kleinen, zurechtgeschnittenen Holzstäbchen versehen werden, um die Kanten zu verstecken. Dadurch entstehen die oben zu sehenden Fensterrahmen. An das obere Fenster wird von innen eine kleine Plexiglasplatte geklebt, um die Cam zu schützen. Hierzu habe ich ebenfalls 2-Komponenten-Kleber verwendet. Bei der Holzplatte für die Rückseite des Häuschens hab ich das Prozedere für das obere Fenster wiederholt, jedoch in ein bisschen größer in vertikaler Hinsicht. Somit ist später von Außen zu sehen, wie viel Futter noch im Häuschen vorhanden ist.</p><figure><img src=../media/projekt/haus_rueckseite.jpeg alt="Fenster in der Rückseite des Häuschens" width=60%><figcaption><p>Fenster in der Rückseite des Häuschens</p></figcaption></figure><p>Um später das Batterie-Case aus dem “Keller” herausnehmen zu können, wird eine kleine Seitentür auf eine Seite des Hauses gebaut. Dazu Sägen wir ein Rechteck in eine der Seitenwände und verschrauben ein kleines Scharnier mit dem ausgeschnittenen Holzstück und der Seitenwand.</p><figure><img src=../media/projekt/keller.jpeg alt="Seitentür für den Keller" width=60%><figcaption><p>Seitentür für den Keller</p></figcaption></figure><p>Beide Seitenwände, Boden und Rückseite können nun in diesem Stadium bereits mit Holzleim zusammengeklebt werden. Dabei sollte auf genug Ruhezeit geachtet werden, um den Leim trocknen zu lassen. Es empfehlen sich außerdem Klammern, die die Komponenten während dem Trocknen zusammenhalten. Für den Zwischenboden im Häuschen, der den “Keller”, in dem später das Batteriecase verstaut wird, vom oberen Teil des Häuschens trennt, werden vier Holzstückchen an die Innenwände auf Höhe der Futteröffnung. Es macht durchaus Sinn, den Zwischenboden ein wenig schräg (hinten höher als vorne) anzubringen, damit das Futter später leichter herausrutscht. Dabei muss, wie auf dem Bild zu sehen, eine Kuhle für die Kabel auf einer Seite gefeilt werden.</p><figure><img src=../media/projekt/haus_innen_zwischenboden.jpeg alt="Haus von Innen, Zwischenboden" width=60%><figcaption><p>Haus von Innen, Zwischenboden</p></figcaption></figure><p>Als nächstes drucken wir das Gehäuse für die ESP-Cam. Das Gehäuse hat an den Innenwänden zwei Schienen. So kann mit Hilfe eines kleinen Holzstäbchens, an dem dann der ESP befestigt wird, die Cam beliebig nach vorne und hinten verstellt werden. Dies ermöglicht ein passgenaues Einstellen der Cam, um möglichst gute Bilder im Endeffekt zu erhalten. Das Case wird mit 2-Komponenten-Kleber auf der Innenseite des Fensters festgeklebt. Die genaue Höhe sollte vorher durch Testbilder ermittelt werden.</p><figure><img src=../media/projekt/haus_innen_cam_offen.jpeg alt="Kamera Case und ESP" width=60%><figcaption><p>Kamera Case und ESP</p></figcaption></figure><p>Die Futterschale wird mit zwei Schrauben und zwei Muttern an der Häuschenvorderseite festgeschraubt und die Kabel von Gewichts- und Vibrationssensor durch die entsprechende Öffnung geführt. Es empfiehlt sich, diese vorher mit einem Schrumpfschlauch zu umhüllen, um zusätzlichen Schutz zu bieten. Auf die Unterseite des Cam-Case hab ich eine kleine Holzplatte geklebt, die ein kleines bisschen weiter ins Innere des Häuschens ragt.Damit schließt die spätere,abnehmbaare Rückwand des Cases bündig mit dem Boden ab. Für meine Cam stellte sich heraus, dass 30 mm Abstand zur Vorderwand eine gute Einstellung für das Sichtfeld der Kamera ist. Ist die Kamera befestigt, so wird noch ein Magnet an einem Holzstäbchen davor geklebt. Um die Technik am ESP zu schützen, habe ich den Magnet zusätzlich mit Isolierband umwickelt.</p><figure><img src=../media/projekt/haus_innen_cam.jpeg alt="Kamera Case fertig" width=60%><figcaption><p>Kamera Case fertig</p></figcaption></figure><p>So können wir auf einer weiteren kleinen Holzplatte in Größe der Öffnung des Kamera-Cases einen weiteren Magnet befestigen und somit einen abnehmbaren Deckel für das Case bauen, so dass der ESP zugänglich bleibt.</p><figure><img src=../media/projekt/haus_innen_kabel.jpeg alt="Kabelführung ESP" width=60%><figcaption><p>Kabelführung ESP</p></figcaption></figure><p>Schließlich werden zwei weitere lasierte Holzplatten benötigt, um das Dach des Häuschens zu bauen. Dabei ist darauf zu achten, dass diese lang genug sind, um die Futterschale und Sitzstange vor dem Häuschen zu schützen. Mit ein wenig Dachpappe werden diese nochmal extra vor Witterung geschützt. Mit jeweils vier Nägeln, einen für jede Ecke, wird die Pappe auf die Holzplatte genagelt. Eine Seite des Daches habe ich mit Holzleim festgeklebt und von Innen kleine, durch Unregelmäßigkeiten entstandene Lücken, mit Heißkleber abgedichtet. Auf diese Seite des Daches habe ich auch einen kleinen Schornstein eingebaut, einschließlich eines Deckels. Durch den Schornstein kann Futter nachgefüllt werden, ohne das Dach des Häuschens abnehmen zu müssen.</p><figure><img src=../media/projekt/dach.jpeg alt="Dach von Innen" width=60%><figcaption><p>Dach von Innen</p></figcaption></figure><p>Auf der anderen Dachseite werden in einem Rechteck so vier Holzstücke geklebt, dass sich das Dach passgenau auf das Häuschen setzen lässt. Dabei muss in das Holzstück, dass an der oberen Seite des Daches sitzt, eine Auskerbung gesägt werden, um den Schornstein freizuhalten (siehe Bild).</p><figure><img src=../media/projekt/dachplatte.jpeg alt="Abnehmbare Dachplatte" width=60%><figcaption><p>Abnehmbare Dachplatte</p></figcaption></figure><p>Zuletzt soll die Futterschale vervollständigt werden. Zwischen Hausvorderwand und oberen Teil des Gewichtssensor-Case kleben wir auf beiden Seiten zwei Holzstücke auf solcher Höhe, dass zwischen ihnen und dem unteren, 3D gedruckten Teil der Futterschale eine kleine Holzplatte passt. Diese sägen wir uns zurecht und können sie nun als herausschiebbaren Boden für die Futterschale verwenden.</p><figure><img src=../media/projekt/Futterschale_boden.jpeg alt=Futterschale width=60%><figcaption><p>Futterschale</p></figcaption></figure><p>Da bei mir das Loch für die Kabelführung etwas zu hoch war, habe ich ein weiteres Holzstück an die Hauswand geklebt, um die Kabel zu verstecken.</p><p>Zuletzt habe ich ein paar Makramee-Fäden verwendet, um kleine Gardinen an das vordere Fenster zu kleben.</p><figure><img src=../media/projekt/fertigeshaus.jpg alt="fertiges Häuschen" width=60%><figcaption><p>fertiges Häuschen</p></figcaption></figure><br><h2 id=lizensierung>Lizensierung</h2><a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/><img alt="Creative Commons License" style=border-width:0 src=https://i.creativecommons.org/l/by-sa/4.0/88x31.png></a><br>This work is licensed under a <a rel=license href=http://creativecommons.org/licenses/by-sa/4.0/>Creative Commons Attribution-ShareAlike 4.0 International License</a>.<ul class=pa0></ul><div class="mt6 instapaper_ignoref"></div></div><aside class="w-30-l mt6-l"></aside></article></main><footer class="bg-near-black bottom-0 w-100 pa3" role=contentinfo><div class="flex justify-between"><a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href=https://annamarburger.github.io/swh/>&copy; Anna Marburger 2023</a><div><div class=ananke-socials></div></div></div></footer></body></html>